import{C as U,D as X,f as H,x as Y,E as Z,G as E,H as D,I as $,J as tt,K as et,L as st,M as nt,N as ot,O as ct,g as K}from"./app-D3_-grU_.js";let M;const L=t=>M=t,rt=Symbol();function k(t){return t&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"&&typeof t.toJSON!="function"}var _;(function(t){t.direct="direct",t.patchObject="patch object",t.patchFunction="patch function"})(_||(_={}));const V=()=>{};function J(t,c,s,e=V){t.push(c);const a=()=>{const u=t.indexOf(c);u>-1&&(t.splice(u,1),e())};return!s&&tt()&&et(a),a}function O(t,...c){t.slice().forEach(s=>{s(...c)})}const ut=t=>t(),F=Symbol(),R=Symbol();function I(t,c){t instanceof Map&&c instanceof Map?c.forEach((s,e)=>t.set(e,s)):t instanceof Set&&c instanceof Set&&c.forEach(t.add,t);for(const s in c){if(!c.hasOwnProperty(s))continue;const e=c[s],a=t[s];k(a)&&k(e)&&t.hasOwnProperty(s)&&!E(e)&&!D(e)?t[s]=I(a,e):t[s]=e}return t}const at=Symbol();function it(t){return!k(t)||!t.hasOwnProperty(at)}const{assign:d}=Object;function ft(t){return!!(E(t)&&t.effect)}function lt(t,c,s,e){const{state:a,actions:u,getters:i}=c,r=s.state.value[t];let b;function h(){r||(s.state.value[t]=a?a():{});const S=ot(s.state.value[t]);return d(S,u,Object.keys(i||{}).reduce((v,g)=>(v[g]=ct(K(()=>{L(s);const m=s._s.get(t);return i[g].call(m,m)})),v),{}))}return b=T(t,h,c,s,e,!0),b}function T(t,c,s={},e,a,u){let i;const r=d({actions:{}},s),b={deep:!0};let h,S,v=[],g=[],m;const j=e.state.value[t];!u&&!j&&(e.state.value[t]={}),H({});let N;function W(o){let n;h=S=!1,typeof o=="function"?(o(e.state.value[t]),n={type:_.patchFunction,storeId:t,events:m}):(I(e.state.value[t],o),n={type:_.patchObject,payload:o,storeId:t,events:m});const f=N=Symbol();nt().then(()=>{N===f&&(h=!0)}),S=!0,O(v,n,e.state.value[t])}const q=u?function(){const{state:n}=s,f=n?n():{};this.$patch(w=>{d(w,f)})}:V;function z(){i.stop(),v=[],g=[],e._s.delete(t)}const A=(o,n="")=>{if(F in o)return o[R]=n,o;const f=function(){L(e);const w=Array.from(arguments),C=[],x=[];function G(l){C.push(l)}function Q(l){x.push(l)}O(g,{args:w,name:f[R],store:y,after:G,onError:Q});let P;try{P=o.apply(this&&this.$id===t?this:y,w)}catch(l){throw O(x,l),l}return P instanceof Promise?P.then(l=>(O(C,l),l)).catch(l=>(O(x,l),Promise.reject(l))):(O(C,P),P)};return f[F]=!0,f[R]=n,f},B={_p:e,$id:t,$onAction:J.bind(null,g),$patch:W,$reset:q,$subscribe(o,n={}){const f=J(v,o,n.detached,()=>w()),w=i.run(()=>st(()=>e.state.value[t],C=>{(n.flush==="sync"?S:h)&&o({storeId:t,type:_.direct,events:m},C)},d({},b,n)));return f},$dispose:z},y=Y(B);e._s.set(t,y);const p=(e._a&&e._a.runWithContext||ut)(()=>e._e.run(()=>(i=Z()).run(()=>c({action:A}))));for(const o in p){const n=p[o];if(E(n)&&!ft(n)||D(n))u||(j&&it(n)&&(E(n)?n.value=j[o]:I(n,j[o])),e.state.value[t][o]=n);else if(typeof n=="function"){const f=A(n,o);p[o]=f,r.actions[o]=n}}return d(y,p),d($(y),p),Object.defineProperty(y,"$state",{get:()=>e.state.value[t],set:o=>{W(n=>{d(n,o)})}}),e._p.forEach(o=>{d(y,i.run(()=>o({store:y,app:e._a,pinia:e,options:r})))}),j&&u&&s.hydrate&&s.hydrate(y.$state,j),h=!0,S=!0,y}function ht(t,c,s){let e,a;const u=typeof c=="function";e=t,a=u?s:c;function i(r,b){const h=X();return r=r||(h?U(rt,null):null),r&&L(r),r=M,r._s.has(e)||(u?T(e,c,a,r):lt(e,a,r)),r._s.get(e)}return i.$id=e,i}const St=ht("auth",()=>{const t=H(null),c=K(()=>!!t.value);return{user:t,isAuthenticated:c,login:async(u,i)=>{const r=await fetch("/api/login",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({email:u,password:i})});if(!r.ok)throw new Error("Login failed");const b=await r.json();t.value=b.user},logout:async()=>{await fetch("/api/logout",{method:"POST"}),t.value=null},register:async(u,i,r,b)=>{const h=await fetch("/api/register",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({name:u,email:i,password:r,role:b})});if(!h.ok)throw new Error("Registration failed");const S=await h.json();t.value=S.user}}});export{St as u};
